expression parser:
- symbols, functions, operators and parentheses
-- symbols
-- functions are unary operators
-- operators are binary operators
** Should I include n-ary functions?
-- parentheses: ['{', '[', '(', ')', ']', '}']


manipulation:
- symbols, operators and parentheses
-- symbols:
--- constants
--- random variables / measurable functions
-- operators:
--- function is unary
    List: ['E', 'I', 'P', 'exp', 'log', 'cup_i', 'sum_i', 'prod_i', 'sqrt', 'abs', 'cplm', \
					'D', 'f', 'norm', 'sup', 'inf', 'limsup', 'liminf']
--- operators are binary
    List: ['+', '-', '*', '/', '^', '<', '>', '<=', '>=', '=', '=>', 'cup', 'cap', 'setDiff', 'symSetDiff', '|', ',']
--- Should I include n-ary functions?

-- parentheses
   List: ['{', '[', '(', ')', ']', '}']


state:
- constant
- random variable / measurable function
- set (for probability)
- interval
- functions
-

operations:
- expectation
- conditional expectation
- max, min, sup, inf

some standard machinary:
- union bound
- equivalent rv
- cauchy schwarz
- Jensen's inequality

Ef(X) \leq f(EX), for concave f
f(EX) \leq E(fX), for convex f
Bounded-difference
sub-gaussian

Todo:
Problem in order:
- state variables
    + This requires a new module handling the namespace. This is done in classVariable.py.
    Next step is to integrate it with TreeParser and MapBuilder. You probably need some experimentation with some functions.
- more general tree mapping creators
    + allow additional input
        * use run-time example generator + MapBuilder
    + allow state variable signature
        * state variables is implemented, but the problem is treeMapping only checks the state of the parent variables, not children. This require state inference for operators and functions.

Key and difficult challenges
- theorem prover (decomposition)
- example creator
- type class proof
- add more theorems


Linear operator (factory)
Real numbers
Function should have description (use dictionary) and equality / inequality label
- Simplify function: (+, -), (*, /), (^, ^), (exp, log)
    - factorising
    - grouping index
    - expanding
    - cancel out
Package
Sub-tree mapping
choose list of proofs

OK - prefix to postfix and postfix natural notation
OK - Equation class - transitivity
OK - Associative Law, Distributive Law
OK - Arithmetic with tree: +, - *, /, ^, exp, log
OK - Equation class: apply function with optional arguments.
OK - partial functional / curry approach to buildParseTree
OK - debug tree Parser for inconsistent parsing with extra '()'
